
To support nested record arrays (a record data type that itself can have 
a nested record type),  I think we need two things

1) Dynamic PyArray_Descr objects, so that an array can have its "own".
I think these need to be actual Python Objects, too, so that we can
support the sharing and proper deallocation of these dynamic
descriptors between arrays (i.e. slices and copies of arrays and so
forth). Dynamic types will initially only be different in two ways:
the element-size and the fields attribute. 

Notice for every flexible-sized array, a new PyArray_Descr object will 
be created since it needs a specific element size.  

2) An additional PyObject * member of the PyArray_Descr structure for
describing the fields.  This is Py_NotImplemented for statically defined types.
For dynamically defined types it is NULL or a dictionary with keys that 
return ordered lists.  This dictionary is a mapping between keys and
a tuple (PyArray_Descr object, offset, [optional title]).  Notice that there 
may be more than one key returning the same item, but the title is always the 
same. 

Doing this allows us to remove the self->itemsize from the array
structure (I think that's a good thing because the size is an
important part of the data-type description).

3)  An additional PyArray_ArrayDescr * member of the PyArray_Descr
    structure for supporting types that are themselves arrays of other
    types. The PyArray_ArrayDescr structure has members PyArray_Descr *,
    PyObject *, for holding a reference to the base-type and
    the shape of the sub-array.

For now, this PyArray_ArrayDescr * member is only really used to get a
higher-dimensional array from PyArray_NewFromDescr.   In other words, arrays
with this structure set are not really useful. 

However, placing it here completes the notion of a type descriptor
and simplies the formats key so that all supported type description 
is handled by the PyArray_Descr structure.  Add a byte-order type to 
descriptor as well so that entire array_descr in protocol can be supported
by a PyArray_Descr structure. 

 
Data type conversions: We can support additional data-type
conversions.  The data-type passed in is converted to a PyArray_Descr*
object.

New possibilities for the "data-type"

Tuple  (flexible type, itemsize)
       (fixed type, shape)
===============================

Get converted to a new PyArray_Descr * object with a flexible
type. The latter structure also sets the PyArray_ArrayDescr field of the
returned PyArray_Descr *.


Dictionary (keys "names", "titles", and "formats")
===============================

This will be converted to a PyArray_VOID type with corresponding
fields parameter (the formats list will be converted to actual
PyArray_Descr * objects).


Objects (anything with an .itemsize and .fields attribute)
=============================== 

If its an instance of (a sub-class of) void type, then a new
PyArray_Descr* structure is created corresponding to its typeobject 
(and PyArray_VOID) typenumber.  If the type is registered, then the
registered type-number is used. 

otherwise a new PyArray_VOID PyArray_Descr* structure is created and
filled ->elsize and ->fields filled in appropriately.

The itemsize attribute must return a number > 0
The fields attribute must return a dictionary with at least 
"names" and "formats" entries.  The "formats" entry will be 
converted to a "proper" descr->fields entry (all generic data-types
converted to PyArray_Descr * structure). 


Reference counting for PyArray_Descr * objects.

Most functions that take PyArary_Descr * as arguments and return a PyObject *
steal the reference unless otherwise noted in the code.

Functions that return PyArray_Descr * objects return a new reference. 
