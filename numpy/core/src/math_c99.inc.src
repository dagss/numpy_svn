/*
 * vim:syntax=c
 * A small module to implement missing C99 math capabilities required by numpy
 *
 * Please keep this independant of python !
 *
 * How to add a function to this section
 * -------------------------------------
 *
 * Say you want to add `foo`, these are the steps and the reasons for them.
 *
 * 1) Add foo to the appropriate list in the configuration system. The
 *    lists can be found in numpy/core/setup.py lines 63-105. Read the
 *    comments that come with them, they are very helpful.
 *
 * 2) The configuration system will define a macro HAVE_FOO if your function
 *    can be linked from the math library. The result can depend on the
 *    optimization flags as well as the compiler, so can't be known ahead of
 *    time. If the function can't be linked, then either it is absent, defined
 *    as a macro, or is an intrinsic (hardware) function. If it is linkable it
 *    may still be the case that no prototype is available. So to cover all the
 *    cases requires the following construction.
 *
 *    i) Undefine any possible macros:
 *
 *    #ifdef foo
 *    #undef foo
 *    #endif
 *
 *    ii) Check if the function was in the library, If not, define the
 *    function with npy_ prepended to its name to avoid conflict with any
 *    intrinsic versions, then use a define so that the preprocessor will
 *    replace foo with npy_foo before the compilation pass. Make the
 *    function static to avoid poluting the module library.
 *
 *    #ifdef foo
 *    #undef foo
 *    #endif
 *    #ifndef HAVE_FOO
 *    static double
 *    npy_foo(double x)
 *    {
 *        return x;
 *    }
 *    #define foo npy_foo
 *
 *    iii) Finally, even if foo is in the library, add a prototype. Just being
 *    in the library doesn't guarantee a prototype in math.h, and in any case
 *    you want to make sure the prototype is what you think it is. Count on it,
 *    whatever can go wrong will go wrong. Think defensively! The result:
 *
 *    #ifdef foo
 *    #undef foo
 *    #endif
 *    #ifndef HAVE_FOO
 *    static double
 *    npy_foo(double x)
 *    {
 *        return x;
 *    }
 *    #define foo npy_foo
 *    #else
 *    double foo(double x);
 *    #end
 *
 *    And there you have it.
 *
 */

/*
 *****************************************************************************
 **                     DISTRO VOODOO                                       **
 *****************************************************************************
 */


/*
 *****************************************************************************
 **                     BASIC MATH FUNCTIONS                                **
 *****************************************************************************
 */

/* Original code by Konrad Hinsen.  */
#ifndef HAVE_EXPM1
static double
npy_expm1(double x)
{
    double u = exp(x);
    if (u == 1.0) {
        return x;
    } else if (u-1.0 == -1.0) {
        return -1;
    } else {
        return (u-1.0) * x/log(u);
    }
}
#define expm1 npy_expm1
#else
double expm1(double x);
#endif

#ifndef HAVE_LOG1P
static double
npy_log1p(double x)
{
    double u = 1. + x;
    if (u == 1.0) {
        return x;
    } else {
        return log(u) * x / (u - 1);
    }
}
#define log1p npy_log1p
#else
double log1p(double x);
#endif

#ifndef HAVE_HYPOT
static double
npy_hypot(double x, double y)
{
    double yx;

    x = fabs(x);
    y = fabs(y);
    if (x < y) {
        double temp = x;
        x = y;
        y = temp;
    }
    if (x == 0.)
        return 0.;
    else {
        yx = y/x;
        return x*sqrt(1.+yx*yx);
    }
}
#define hypot npy_hypot
#else
double hypot(double x, double y);
#endif

#ifndef HAVE_ACOSH
static double
npy_acosh(double x)
{
    return 2*log(sqrt((x+1.0)/2)+sqrt((x-1.0)/2));
}
#define acosh npy_acosh
#else
double acosh(double x);
#endif

#ifndef HAVE_ASINH
static double
npy_asinh(double xx)
{
    double x, d;
    int sign;
    if (xx < 0.0) {
        sign = -1;
        x = -xx;
    }
    else {
        sign = 1;
        x = xx;
    }
    if (x > 1e8) {
        d = x;
    } else {
        d = sqrt(x*x + 1);
    }
    return sign*log1p(x*(1.0 + x/(d+1)));
}
#define asinh npy_asinh
#else
double asinh(double xx);
#endif

#ifndef HAVE_ATANH
static double
npy_atanh(double x)
{
    return 0.5*log1p(2.0*x/(1.0-x));
}
#define atanh npy_atanh
#else
double atanh(double x);
#endif

#ifndef HAVE_RINT
static double
npy_rint(double x)
{
    double y, r;

    y = floor(x);
    r = x - y;

    if (r > 0.5) goto rndup;

    /* Round to nearest even */
    if (r==0.5) {
        r = y - 2.0*floor(0.5*y);
        if (r==1.0) {
        rndup:
            y+=1.0;
        }
    }
    return y;
}
#define rint npy_rint
#else
double rint(double x);
#endif

#ifndef HAVE_TRUNC
static double
npy_trunc(double x)
{
    return x < 0 ? ceil(x) : floor(x);
}
#define trunc npy_trunc
#else
double trunc(double x);
#endif

#ifndef HAVE_EXP2
#define LOG2 0.69314718055994530943
static double
npy_exp2(double x)
{
    return exp(LOG2*x);
}
#define exp2 npy_exp2
#undef LOG2
#else
double exp2(double x);
#endif

#ifndef HAVE_LOG2
#define INVLOG2 1.4426950408889634074
static double
npy_log2(double x)
{
    return INVLOG2*log(x);
}
#define log2 npy_log2
#undef INVLOG2
#else
double log2(double x);
#endif

/*
 *****************************************************************************
 **                     IEEE 754 FPU HANDLING                               **
 *****************************************************************************
 */
#if !defined(HAVE_DECL_ISNAN)
    # define isnan(x) ((x) != (x))
#endif

/* VS 2003 with /Ox optimizes (x)-(x) to 0, which is not IEEE compliant. So we
 * force (x) + (-x), which seems to work. */
#if !defined(HAVE_DECL_ISFINITE)
    # define isfinite(x) !isnan((x) + (-x))
#endif

#if !defined(HAVE_DECL_ISINF)
#define isinf(x) (!isfinite(x) && !isnan(x))
#endif

#if !defined(HAVE_DECL_SIGNBIT)
    #include "_signbit.c"
    # define signbit(x) \
              (sizeof (x) == sizeof (long double) ? signbit_ld (x) \
               : sizeof (x) == sizeof (double) ? signbit_d (x) \
               : signbit_f (x))

static int signbit_f (float x)
{
    return signbit_d((double)x);
}

static int signbit_ld (long double x)
{
    return signbit_d((double)x);
}
#endif

/*
 * if C99 extensions not available then define dummy functions that use the
 * double versions for
 *
 * sin, cos, tan
 * sinh, cosh, tanh,
 * fabs, floor, ceil, rint, trunc
 * sqrt, log10, log, exp, expm1
 * asin, acos, atan,
 * asinh, acosh, atanh
 *
 * hypot, atan2, pow, fmod, modf
 *
 * We assume the above are always available in their double versions.
 *
 * NOTE: some facilities may be available as macro only  instead of functions.
 * For simplicity, we define our own functions and undef the macros. We could
 * instead test for the macro, but I am lazy to do that for now.
 */

/**begin repeat
 * #type = longdouble, float#
 * #TYPE = LONGDOUBLE, FLOAT#
 * #c = l,f#
 * #C = L,F#
 */

/**begin repeat1
 * #kind = sin,cos,tan,sinh,cosh,tanh,fabs,floor,ceil,rint,trunc,sqrt,log10,
 *         log,exp,expm1,asin,acos,atan,asinh,acosh,atanh,log1p,exp2,log2#
 * #KIND = SIN,COS,TAN,SINH,COSH,TANH,FABS,FLOOR,CEIL,RINT,TRUNC,SQRT,LOG10,
 *         LOG,EXP,EXPM1,ASIN,ACOS,ATAN,ASINH,ACOSH,ATANH,LOG1P,EXP2,LOG2#
 */

#ifdef @kind@@c@
#undef @kind@@c@
#endif
#ifndef HAVE_@KIND@@C@
static @type@
npy_@kind@@c@(@type@ x)
{
    return (@type@) @kind@((double)x);
}
#define @kind@@c@  npy_@kind@@c@
#else
@type@ @kind@@c@(@type@ x);
#endif

/**end repeat1**/

/**begin repeat1
 * #kind = atan2,hypot,pow,fmod#
 * #KIND = ATAN2,HYPOT,POW,FMOD#
 */
#ifdef @kind@@c@
#undef @kind@@c@
#endif
#ifndef HAVE_@KIND@@C@
static @type@
npy_@kind@@c@(@type@ x, @type@ y)
{
    return (@type@) @kind@((double)x, (double) y);
}
#define @kind@@c@  npy_@kind@@c@
#else
@type@ @kind@@c@(@type@ x, @type@ y);
#endif
/**end repeat1**/

#ifdef modf@c@
#undef modf@c@
#endif
#ifndef HAVE_MODF@C@
static @type@
npy_modf@c@(@type@ x, @type@ *iptr)
{
    double niptr;
    double y = modf((double)x, &niptr);
    *iptr = (@type@) niptr;
    return (@type@) y;
}
#define modf@c@ npy_modf@c@
#else
@type@ modf@c@(@type@ x, @type@ *iptr);
#endif

/**end repeat**/
