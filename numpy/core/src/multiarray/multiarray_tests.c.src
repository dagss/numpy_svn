#include <Python.h>

#include "numpy/ndarrayobject.h"

/*
 * TODO:
 *  - Handle mode
 */

/**begin repeat
 * #type = double, int#
 * #typenum = NPY_DOUBLE, NPY_INT#
 */
static int copy_@type@(PyArrayIterObject *itx, PyArrayNeighborhoodIterObject *niterx,
        npy_intp *bounds,
        PyObject **out)
{
    npy_intp i, j;
    @type@ *ptr;
    npy_intp odims[NPY_MAXDIMS];
    PyArrayObject *aout;

    /* For each point in itx, copy the current neighborhood into an array which
     * is appended at the output list */
    for(i = 0; i < itx->size; ++i) {
        npy_intp coord[10];
        PyArrayNeighborhoodIter_Reset(niterx);

#if 0
        printf("+++++++++++++++++++++++++++++++\n");
        coord[0] = -2;
        printf("%f\n", *((double*)niterx->translate(niterx, coord)));
        coord[0] = -1;
        printf("%f\n", *((double*)niterx->translate(niterx, coord)));
        coord[0] = 0;
        printf("%f\n", *((double*)niterx->translate(niterx, coord)));
        coord[0] = 1;
        printf("%f\n", *((double*)niterx->translate(niterx, coord)));
        coord[0] = 2;
        printf("%f\n", *((double*)niterx->translate(niterx, coord)));
#endif
        for(j = 0; j < itx->ao->nd; ++j) {
            odims[j] = bounds[2 * j + 1] - bounds[2 * j] + 1;
        }
        aout = (PyArrayObject*)PyArray_SimpleNew(itx->ao->nd, odims, @typenum@);
        if (aout == NULL) {
            return -1;
        }

        ptr = (@type@*)aout->data;

        for(j = 0; j < niterx->size; ++j) {
            *ptr = *((@type@*)niterx->dataptr);
            PyArrayNeighborhoodIter_Next(niterx);
            ptr += 1;
        }

        Py_INCREF(aout);
        PyList_Append(*out, (PyObject*)aout);
        Py_DECREF(aout);
        PyArray_ITER_NEXT(itx);
    }

    return 0;
}
/**end repeat**/

static int copy_object(PyArrayIterObject *itx, PyArrayNeighborhoodIterObject *niterx,
        npy_intp *bounds,
        PyObject **out)
{
    npy_intp i, j;
    npy_intp odims[NPY_MAXDIMS];
    PyArrayObject *aout;
    PyArray_CopySwapFunc *copyswap = itx->ao->descr->f->copyswap;
    npy_int itemsize = PyArray_ITEMSIZE(itx->ao);

    /* For each point in itx, copy the current neighborhood into an array which
     * is appended at the output list */
    for(i = 0; i < itx->size; ++i) {
        PyArrayNeighborhoodIter_Reset(niterx);

        for(j = 0; j < itx->ao->nd; ++j) {
            odims[j] = bounds[2 * j + 1] - bounds[2 * j] + 1;
        }
        aout = (PyArrayObject*)PyArray_SimpleNew(itx->ao->nd, odims, NPY_OBJECT);
        if (aout == NULL) {
            return -1;
        }

        for(j = 0; j < niterx->size; ++j) {
            copyswap(aout->data + j * itemsize, niterx->dataptr, 0, NULL);
            PyArrayNeighborhoodIter_Next(niterx);
        }

        Py_INCREF(aout);
        PyList_Append(*out, (PyObject*)aout);
        Py_DECREF(aout);
        PyArray_ITER_NEXT(itx);
    }

    return 0;
}
static PyObject*
test_neighborhood_iterator(PyObject* NPY_UNUSED(self), PyObject* args)
{
    PyObject *x, *fill, *out, *b;
    PyArrayObject *ax, *afill;
    PyArrayIterObject *itx;
    int i, typenum, mode, st;
    npy_intp bounds[NPY_MAXDIMS*2];
    PyArrayNeighborhoodIterObject *niterx;

    if (!PyArg_ParseTuple(args, "OOOi", &x, &b, &fill, &mode)) {
        return NULL;
    }

    if (!PySequence_Check(b)) {
        return NULL;
    }

    typenum = PyArray_ObjectType(x, 0);
    typenum = PyArray_ObjectType(fill, typenum);

    ax = (PyArrayObject*)PyArray_FromObject(x, typenum, 1, 10);
    if (ax == NULL) {
        return NULL;
    }
    if (PySequence_Size(b) != 2 * ax->nd) {
        PyErr_SetString(PyExc_ValueError,
                "bounds sequence size not compatible with x input");
        goto clean_ax;
    }

    out = PyList_New(0);
    if (out == NULL) {
        goto clean_ax;
    }

    itx = (PyArrayIterObject*)PyArray_IterNew(x);
    if (itx == NULL) {
        goto clean_out;
    }

    /* Compute boundaries for the neighborhood iterator */
    for(i = 0; i < 2 * ax->nd; ++i) {
        PyObject* bound;
        bound = PySequence_GetItem(b, i);
        if (bounds == NULL) {
            goto clean_itx;
        }
        if (!PyInt_Check(bound)) {
            PyErr_SetString(PyExc_ValueError, "bound not long");
            Py_DECREF(bound);
            goto clean_itx;
        }
        bounds[i] = PyInt_AsLong(bound);
        Py_DECREF(bound);
    }

    /* Create the neighborhood iterator */
    afill = NULL;
    if (mode == NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING) {
	    afill = (PyArrayObject *)PyArray_FromObject(fill, typenum, 0, 0);
	    if (afill == NULL) {
            goto clean_itx;
        }
    }

    niterx = (PyArrayNeighborhoodIterObject*)PyArray_NeighborhoodIterNew(
                    (PyArrayIterObject*)itx, bounds, mode, afill);
    if (niterx == NULL) {
        goto clean_afill;
    }

    switch (typenum) {
        case NPY_OBJECT:
            st = copy_object(itx, niterx, bounds, &out);
            break;
        case NPY_INT:
            st = copy_int(itx, niterx, bounds, &out);
            break;
        case NPY_DOUBLE:
            st = copy_double(itx, niterx, bounds, &out);
            break;
        default:
            PyErr_SetString(PyExc_ValueError, "Type not supported");
            goto clean_niterx;
    }

    if (st) {
        goto clean_niterx;
    }

    Py_DECREF(niterx);
    Py_XDECREF(afill);
    Py_DECREF(itx);

    Py_DECREF(ax);

    return out;

clean_niterx:
    Py_DECREF(niterx);
clean_afill:
    Py_XDECREF(afill);
clean_itx:
    Py_DECREF(itx);
clean_out:
    Py_DECREF(out);
clean_ax:
    Py_DECREF(ax);
    return NULL;
}

/*
 * Update to next item of the iterator
 *
 * Note: this simply increment the coordinates vector, last dimension
 * incremented first , i.e, for dimension 3
 * ...
 * -1, -1, -1
 * -1, -1,  0
 * -1, -1,  1
 *  ....
 * -1,  0, -1
 * -1,  0,  0
 *  ....
 * 0,  -1, -1
 * 0,  -1,  0
 *  ....
 */
#define _UPDATE_COORD_ITER(c) \
    wb = iter->coordinates[c] < iter->bounds[c][1]; \
    if (wb) { \
        iter->coordinates[c] += 1; \
        return 0; \
    } \
    else { \
        iter->coordinates[c] = iter->bounds[c][0]; \
    }

static inline int
neigh_iter_incr_coord(PyArrayNeighborhoodIterObject* iter)
{
    int i, wb;

    for (i = iter->nd - 1; i >= 0; --i) {
        _UPDATE_COORD_ITER(i)
    }

    return 0;
}
#undef _UPDATE_COORD_ITER

#if 0
#define _INF_SET_PTR(c) \
    bd = niter->coordinates[c] + niter->_internal_iter->coordinates[c]; \
    printf("%d|%d - %d|%d,\n", niter->coordinates[c], \
            niter->_internal_iter->coordinates[c], \
            niter->_internal_iter->bounds[c][0], \
            niter->_internal_iter->bounds[c][1]); \
    if (bd < niter->_internal_iter->bounds[c][0] || \
        bd > niter->_internal_iter->bounds[c][1]) { \
        printf("OOB\n"); \
        return niter->constant; \
    } \
    coordinates[c] = bd;  \
    printf("coord is %d\n", coordinates[c]);
#endif

#define _INF_SET_PTR(c) \
    bd = niter->coordinates[c] + p->coordinates[c]; \
    if (bd < p->bounds[c][0] || \
        bd > p->bounds[c][1]) { \
        return niter->constant; \
    } \
    _coordinates[c] = bd;

static inline char*
neigh_iter_get_ptr_const(PyArrayNeighborhoodIterObject* niter)
{
    int i;
    npy_intp offset, bd;
    char *ret;
    PyArrayIterObject *p = niter->_internal_iter;
    npy_intp _coordinates[2*NPY_MAXDIMS];

    for(i = 0; i < niter->nd; ++i) {
        _INF_SET_PTR(i)
    }

    return niter->_internal_iter->translate(niter->_internal_iter, _coordinates);
}

static inline int
neigh_iter_next_fptr(PyArrayNeighborhoodIterObject *iter)
{
	neigh_iter_incr_coord(iter);
	iter->dataptr = neigh_iter_get_ptr_const(iter);
	return 0;
}

static inline int
neigh_iter_reset(PyArrayNeighborhoodIterObject *iter)
{
    npy_intp i;

    for(i = 0; i < iter->nd; ++i) {
        iter->coordinates[i] = iter->bounds[i][0];
    }
	iter->dataptr = neigh_iter_get_ptr_const(iter);
	return 0;
}

//#include "cycle.h"

//ticks T0, T1;
double RES;
double _MAX;

#define _NPY_IS_EVEN(x) ((x) % 2 == 0)

/* For an array x of dimension n, and given index i, returns j, 0 <= j < n
 * such as x[i] = x[j], with x assumed to be mirrored. For example, for x =
 * {1, 2, 3} (n = 3)
 *
 * index -5 -4 -3 -2 -1 0 1 2 3 4 5 6
 * value  2  3  3  2  1 1 2 3 3 2 1 1
 *
 * _npy_pos_index_mirror(4, 3) will return 1, because x[4] = x[1]*/
static inline npy_intp
__npy_pos_remainder(npy_intp i, npy_intp n)
{
    npy_intp k, l, j;

    /* Mirror i such as it is guaranteed to be positive */
    if (i < 0) {
        i = - i - 1;
    }

    /* compute k and l such as i = k * n + l, 0 <= l < k */
    k = i / n;
    l = i - k * n;

    if (_NPY_IS_EVEN(k)) {
        j = l;
    } else {
        j = n - 1 - l;
    }
    return j;
}
#undef _NPY_IS_EVEN

#define _INF_SET_PTR_MIRROR(c) \
    bd = coordinates[c] + p->coordinates[c]; \
    bd -= p->bounds[c][0]; \
    truepos = __npy_pos_remainder(bd, niter->dimensions[c] - p->bounds[c][0]); \
    _coordinates[c] = (truepos - p->coordinates[c] + p->bounds[c][0]);

/* set the dataptr from its current coordinates */
static char*
get_ptr_mirror(PyArrayIterObject* _iter, npy_intp *coordinates)
{
    int i;
    npy_intp bd, _coordinates[NPY_MAXDIMS];
    npy_intp truepos;
    PyArrayNeighborhoodIterObject *niter = (PyArrayNeighborhoodIterObject*)_iter;
    PyArrayIterObject *p = niter->_internal_iter;

    printf("%s\n", __func__);
    for(i = 0; i < niter->nd; ++i) {
        _INF_SET_PTR_MIRROR(i)
    }

    printf("%s:%s: coordinates is %ld, ptr is %f\n", __FILE__, __func__, _coordinates[0], *((double*)p->translate(p, _coordinates)));
    return p->translate(p, _coordinates);
}
#undef _INF_SET_PTR_MIRROR

static int 
copy_double_double(PyArrayNeighborhoodIterObject *itx, 
        PyArrayNeighborhoodIterObject *niterx,
        npy_intp *bounds,
        PyObject **out)
{
    npy_intp i, j, k;
    register double *ptr;
    npy_intp odims[NPY_MAXDIMS];
    PyArrayObject *aout;

    /* For each point in itx, copy the current neighborhood into an array which
     * is appended at the output list */
	// itx->translate = &get_ptr_mirror;
    PyArrayNeighborhoodIter_Reset(itx);
    _MAX = 1e100;
    for(i = 0; i < itx->size; ++i) {
#if 0
		npy_intp yo[10];
		yo[0] = i;
        printf("====================\n");
		printf("(%f) \n", *((double*)itx->translate(itx, yo)));
		// printf("(%f) \n", *((double*)itx->dataptr));

        PyArrayNeighborhoodIter_Reset(niterx);
        printf("------ begin --------------\n");
        //T0 = getticks();
        for(j = 0; j < niterx->size; ++j) {
			printf("(%f) \n", *((double*)niterx->translate(niterx, niterx->coordinates)));
			// printf("(%f) \n", *((double*)niterx->dataptr));
            PyArrayNeighborhoodIter_Next(niterx);
		}
        printf("------ end -------------\n");

		// yo[0] = 1;
		// printf("(%f) \n", *((double*)itx->translate(itx, yo)));
		// yo[0] = 2;
		// printf("(%f) \n", *((double*)itx->translate(itx, yo)));
		// yo[0] = 3;
		// printf("(%f) \n", *((double*)itx->translate(itx, yo)));
		// yo[0] = 4;
		// printf("(%f) \n", *((double*)itx->translate(itx, yo)));

		// yo[0] = -1;
		// printf("(%f) \n", *((double*)niterx->translate(niterx, yo)));
#endif
        for(j = 0; j < itx->ao->nd; ++j) {
            odims[j] = bounds[2 * j + 1] - bounds[2 * j] + 1;
        }
        aout = (PyArrayObject*)PyArray_SimpleNew(itx->ao->nd, odims, NPY_DOUBLE);
        if (aout == NULL) {
            return -1;
        }

        ptr = (double*)aout->data;

        PyArrayNeighborhoodIter_Reset(niterx);
        //T0 = getticks();
        for(j = 0; j < niterx->size; ++j) {
            *ptr = *((double*)niterx->dataptr);
            ptr += 1;
            PyArrayNeighborhoodIter_Next(niterx);
        }
        //T1 = getticks();
        //RES = elapsed(T1, T0);
        //if (RES < _MAX) {
        //    _MAX = RES;
        //}

        Py_INCREF(aout);
        PyList_Append(*out, (PyObject*)aout);
        Py_DECREF(aout);
        PyArrayNeighborhoodIter_Next(itx);
    }
   //  printf("%f - %f\n", _MAX, _MAX / niterx->size);

#if 0
	{
		npy_intp coord[10];
		coord[0] = 0;
		coord[1] = 0;
		*ptr = *((double*)niterx->translate(niterx, coord));
		printf("%f\n", *ptr);
		coord[0] = 1;
		coord[1] = 0;
		*ptr = *((double*)niterx->translate(niterx, coord));
		printf("%f\n", *ptr);
		coord[0] = 2;
		coord[1] = 0;
		*ptr = *((double*)niterx->translate(niterx, coord));
		printf("%f\n", *ptr);
	}
#endif

    return 0;
}

static PyObject*
test_neighborhood_iterator_oob(PyObject* NPY_UNUSED(self), PyObject* args)
{
    PyObject *x, *out, *b1, *b2;
    PyArrayObject *ax;
    PyArrayIterObject *itx;
    int i, typenum, mode1, mode2, st;
    npy_intp bounds[NPY_MAXDIMS*2];
    PyArrayNeighborhoodIterObject *niterx1, *niterx2;

    if (!PyArg_ParseTuple(args, "OOiOi", &x, &b1, &mode1, &b2, &mode2)) {
        return NULL;
    }

    if (!PySequence_Check(b1) || !PySequence_Check(b2)) {
        return NULL;
    }

    typenum = PyArray_ObjectType(x, 0);

    ax = (PyArrayObject*)PyArray_FromObject(x, typenum, 1, 10);
    if (ax == NULL) {
        return NULL;
    }
    if (PySequence_Size(b1) != 2 * ax->nd) {
        PyErr_SetString(PyExc_ValueError,
                "bounds sequence 1 size not compatible with x input");
        goto clean_ax;
    }
    if (PySequence_Size(b2) != 2 * ax->nd) {
        PyErr_SetString(PyExc_ValueError,
                "bounds sequence 2 size not compatible with x input");
        goto clean_ax;
    }

    out = PyList_New(0);
    if (out == NULL) {
        goto clean_ax;
    }

    itx = (PyArrayIterObject*)PyArray_IterNew(x);
    if (itx == NULL) {
        goto clean_out;
    }

    /* Compute boundaries for the neighborhood iterator */
    for(i = 0; i < 2 * ax->nd; ++i) {
        PyObject* bound;
        bound = PySequence_GetItem(b1, i);
        if (bounds == NULL) {
            goto clean_itx;
        }
        if (!PyInt_Check(bound)) {
            PyErr_SetString(PyExc_ValueError, "bound not long");
            Py_DECREF(bound);
            goto clean_itx;
        }
        bounds[i] = PyInt_AsLong(bound);
        Py_DECREF(bound);
    }

    /* Create the neighborhood iterator */
    niterx1 = (PyArrayNeighborhoodIterObject*)PyArray_NeighborhoodIterNew(
                    (PyArrayIterObject*)itx, bounds,
                    mode1, NULL);
    if (niterx1 == NULL) {
        goto clean_out;
    }

    for(i = 0; i < 2 * ax->nd; ++i) {
        PyObject* bound;
        bound = PySequence_GetItem(b2, i);
        if (bounds == NULL) {
            goto clean_itx;
        }
        if (!PyInt_Check(bound)) {
            PyErr_SetString(PyExc_ValueError, "bound not long");
            Py_DECREF(bound);
            goto clean_itx;
        }
        bounds[i] = PyInt_AsLong(bound);
        Py_DECREF(bound);
    }

    niterx2 = (PyArrayNeighborhoodIterObject*)PyArray_NeighborhoodIterNew(
                    (PyArrayIterObject*)niterx1, bounds,
                    mode2, NULL);
    if (niterx1 == NULL) {
        goto clean_niterx1;
    }

    switch (typenum) {
        case NPY_DOUBLE:
            st = copy_double_double(niterx1, niterx2, bounds, &out);
            break;
        default:
            PyErr_SetString(PyExc_ValueError, "Type not supported");
            goto clean_niterx2;
    }

    if (st) {
        goto clean_niterx2;
    }

    Py_DECREF(niterx2);
    Py_DECREF(niterx1);
    Py_DECREF(itx);

    Py_DECREF(ax);

    return out;

clean_niterx2:
    Py_DECREF(niterx2);
clean_niterx1:
    Py_DECREF(niterx1);
clean_itx:
    Py_DECREF(itx);
clean_out:
    Py_DECREF(out);
clean_ax:
    Py_DECREF(ax);
    return NULL;
}

static PyMethodDef Multiarray_TestsMethods[] = {
    {"test_neighborhood_iterator",  test_neighborhood_iterator, METH_VARARGS, NULL},
    {"test_neighborhood_iterator_oob",  test_neighborhood_iterator_oob, METH_VARARGS, NULL},
    {NULL, NULL, 0, NULL}        /* Sentinel */
};

PyMODINIT_FUNC
initmultiarray_tests(void)
{
    PyObject *m;

    m = Py_InitModule("multiarray_tests", Multiarray_TestsMethods);
    if (m == NULL) return;

    import_array();

    if (PyErr_Occurred()) {
        PyErr_SetString(PyExc_RuntimeError,
                        "cannot load umath_tests module.");
    }
}
