.. -*- rest -*-

============================================
ExtGen --- Python extension module generator
============================================

:Author:
  Pearu Peterson <pearu.peterson@gmail.com>
:Created: August 2007

.. contents:: Table of Contents

Introduction
============

ExtGen is a pure Python package that provides a high-level
tool for constructing and building Python extension modules.
Hello example follows::

  >>> from numpy.f2py.lib.extgen import *
  >>> m = ExtensionModule('foo')
  >>> f = PyCFunction('hello')
  >>> f += 'printf("Hello!\\n");'
  >>> m += f
  >>> print m.generate() # shows a string containing C source to extension module
  >>> foo = m.build()
  >>> foo.hello()
  Hello!
  >>> 


Description of the ExtGen model
===============================

To extend ExtGen, one needs to understand the infrastructure of
generating extension modules.

There are two important concepts in ExtGen model: components and
containers. Components (ref. class `Component`) define code blocks or
code idioms used in building up a code sources. Containers (ref. class
`Container`) are named string lists that are joined together with
specified rules resulting actual code sources. ExtGen uses two steps
for constructing code sources:

- creating code components and adding them together to a parent
  component. For example, the `ExtensionModule` instance in the
  hello example becomes a parent component to a `PyCFunction` instance
  after executing `m += f`.

- generating code source by calling `.generate()` method of the
  parent component.

One can iterate the above process as one wishes.

The method `ExtensionModule.build()` is defined for convenience.
It compiles the generated sources, builds an extension module,
imports the resulting module to Python, and returns the module object.

All component classes must be derived from the base class `Component`
defined in `extgen/base.py` file. `Component` class defines the
following methods and attributes:

- `.initialize(self, *args, **kws)` is used to initialize the attributes
  and subcomponents of the `Component` instance. Derived classes
  usually redefine it to define the signature of the component
  constructor.

- `.add(self, component, container_label=None)` is used to add
  subcomponents to the `Component`. Derived classes can affect
  the behavior of the `.add()` method by redefining the following
  class attributes:

  - `.default_component_class_name` is used when the `component`
    argument is not a `Component` instance.

  - `.default_container_label` is used when component
    `container_label` is undefined. 

  - `.component_containe_map` is used to find `container_label`
    corresponding to `component` argument class.

- `.generate(self)` returns a source code string. It recursively
  processes all subcomponents, creates code containers, and
  evaluates code templates.

- `.provides(self)` property method returns an unique string
  labeling the current component. The label is used to name
  the result of `.generate()` method when storing it to a container.
  The result is saved to container only if container does not
  contain the given provides label. With this feature one avoids
  redefining the same functions, variables, types etc that are needed
  by different components.

- `.init_containers(self)` is called before processing subcomponents.
  Derived classes may redefine it.

- `.update_containers(self)` is called after processing subcomponents.
  Derived classes usually define it to fill up any containers.

- `.get_templates(self)` is used by `.generate()` method to evaluate
  the templates and return results. By default, `.get_templates()`
  returns `.template` attribute. Derived classes may redefine it
  to return a tuple of templates, then also `.generate()` will
  return a tuple of source code strings.

- `.get_container(self, name)` or `.container_<name>` can be used
  to retrive a container with a given name. If the current component
  does not have requested container then the method tries to find
  the container from parent classes. If it still does not find it,
  then a new container with the given name will be created for
  the current component. One should acctually avoid the last
  solution and always define the containers in `.container_options`
  class attribute. This attribute is a mapping between container
  names and keyword options to the `Container` constructor.
  See `Container` options below for more detail.

- `.evaluate(self, template)` will evaluate `template` using
  the attributes (with string values) and the code from containers.

- `.info(message)`, `.warning(message)` are utility methods and
  will write messages to `sys.stderr`.

- `.register(*components)` will register predefined components
  that can be retrived via `.get(provides)` method.

Deriving a new `Component` class involves the following
tasks:

- A component class must have a base class `Component`.

- A component class may redefine `.initialize()`,
  `.init_containers()`, `.update_containers()`, `.get_templates()`
  methods, `.provides()` property method and `.container_options`,
  `.component_container_map`, `.default_container_label`,
  `.default_component_class_name`, `.template` attributes.

- In `.initialize()` method one can process constructor options,
  set new attributes and add predefined components. It must
  return a `Component` instance.

- In `.init_containers()` and `.update_containers()` methods
  one may retrive containers from parents via `.get_container(<name>)`
  method or `.container_<name>` attribute and fill them using
  `.add()` method of the container.

- The attribute `.template` is a string containing formatting mapping keys
  that correspond to containers names or instance attribute names.

- The attribute `.container_options` is a mapping of container
  names and keyword argument dictionaries used as options
  to a `Container` constructor.

- The attribute `.component_container_map` is a mapping between
  subcomponent class names and the names of containers that should
  be used to save the code generation results.

- All classes derived from `Component` are available as
  `Component.<subclass name>`.

Here follows a simplified version of `ExtensionModule.template`::

  #include "Python.h"
  
  %(Header)s
  %(TypeDef)s
  %(Extern)s
  %(CCode)s
  %(CAPICode)s
  %(ObjDecl)s
  
  static PyObject* extgen_module;
  
  static PyMethodDef extgen_module_methods[] = {
    %(ModuleMethod)s
    {NULL,NULL,0,NULL}
  };
  
  PyMODINIT_FUNC init%(modulename)s(void) {
    extgen_module = Py_InitModule("%(modulename)s", extgen_module_methods);
    %(ModuleInit)s
    return;
  capi_error:
    if (!PyErr_Occurred()) {
      PyErr_SetString(PyExc_RuntimeError, "failed to initialize %(modulename)s module.");
    }
    return;
  }

Here formatting mapping keys `Header`, `TypeDef`, etc are the labels
of containers which will be used in the templare evaluation.
See `extgen/*.py` files for more examples how to redefine `Component`
class methods and attributes.


Using `Container` class
=======================
    
`Container` class has the following optional arguments:

  - `separator='\n'`
  - `prefix=''`
  - `suffix=''`
  - `skip_prefix_when_empty=False`
  - `skip_suffix_when_empty=False`
  - `default=''`
  - `reverse=False`
  - `use_indent=False`
  - `use_firstline_indent=False`
  - `indent_offset=0`
  - `user_defined_str=None`
  - `replace_map={}`

that are used to enhance the behaviour of `Container.__str__()`
method.  By default, `Container.__str__()` returns
`prefix+separator.join(<Container instance>.list)+suffix`.

One can add items to `Container` instance using `.add(<string>,
label=None)` method. The items are saved in `.list` and `.label_map`
attributes.

`Container` instances can be combined using `+` operator and
copied with `.copy()` method. The `.copy()` method has the
same arguments as `Container` constructor and can be used
to change certain container properties.

The `label` argument should contain an unique value that represents
the content of `<string>`.  If `label` is `None` then `label =
time.time()` will be set.

If one tries to add items with the same label to the container then
the equality of the corresponding string values will be checked. If
they are not equal then `ValueError` is raised, otherwise adding an
item is ignored.

If `reverse` is `True` then the `.list` is reversed before joining
its items. If `use_indent` is `True` then each item in `.list` will
be prefixed with `indent_offset` spaces. If `use_firstline_indent` is
`True` then additional indention of the number of starting spaces
in `.line[0]` is used. The `replace_map` is used to apply
`.replace(key, value)` method to the result of `__str__()`.
Full control over the `__str__()` method is obtained via
defining `user_defined_str` that should be a callable object taking
list as input and return a string.


Component classes
=================

ExtGen package defines the following extension module component classes:

  - `ExtensionModule(<modulename>, *components, numpy=False,
    provides=.., title=.., description=..)`  ---
    represents an extension module component. If `numpy` is `True` then
    `NumPy` support will be added to an extension module.
    
  - `PyCFunction(<name>, *components, provides=.., title=.., description=..)` ---
    represents an extension function component.

  - `PyCArgument(<name>, *components, provides=.., input_intent=..,
    output_intent=.., input_title=.., input_description=..,
    output_title=, output_description=..)` --- represents an argument component for
    `PyCFunction`. Keyword arguments `input_intent` and
    `output_intent` may have values `'required'`, `'optional'`,
    `'extra'`, `'hide'` and `'hide'`, `'return'`, respectively.

  - `CCode(*lines, provides=..)` --- represents any C code block or
    statement component.

  - `CType(<name or python type obj>)` --- represents a predefined or intrinsic C type
    with a given name.

  - `CTypeAlias(<name>, <ctype>)` --- represents `typedef ctype name;`
    declaration.

  - `CTypeFuncAlias(<name>, <return ctype>, <argument ctypes>)` ---
    represents `typedef rctype (*name)(actype1,..)` declaration.
    Use `.add()` method to add more argument types.

  - `CTypePtr(<ctype>)` --- represents `typedef ctype* ctype_ptr;`
    declaration.

  - `CTypeStruct(<name>, *declarations)` --- represents `typedef struct {
    <declarations> } name;` declaration. Use `.add()` method to add
    more declarations.

  - `CDecl(<ctype>, *names)` --- represents `ctype name1, name2, ..;`
    declaration. Use `.add()` method to add more names.

  - `CTypePython(<python type object or 'cell' or 'generator' or 'cobject' or 'instance'>)` 
    --- represents python type object in C.


Predefined components
=====================

ExtGen defines the following components that can be retrived
using `Component.get(<provides>)` method:

- `'Python.h'` - include `Pyhton.h` header file.

- `'arrayobject.h'` - include NumPy header files.

- `'import_array'` - code for importing numpy package to extension
  module.

- `'int'` - C `int` type support
