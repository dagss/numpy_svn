.. -*- rest -*-

============================================
ExtGen --- Python extension module generator
============================================

:Author:
  Pearu Peterson <pearu.peterson@gmail.com>
:Created: August 2007

.. contents:: Table of Contents

Introduction
============

ExtGen is a pure Python package that provides a high-level
tool for constructing and building Python extension modules.
Hello example follows::

  >>> from numpy.f2py.lib.extgen import *
  >>> m = ExtensionModule('foo')
  >>> f = PyCFunction('hello')
  >>> f += 'printf("Hello!\\n");'
  >>> m += f
  >>> m.generate() # returns a string containing C source to extension module
  >>> foo = m.build()
  >>> foo.hello()
  Hello!
  >>> 


Extending ExtGen
================

To extend ExtGen, one needs to understand the infrastructure of
generating extension modules.

The `extgen` package provides many classes that are derived from Base
class (defined in extgen/base.py).  Each such a class represents
certain code block or a code idiom in an extension module that is
defined in `.template` attribute.  Most important `Base` methods, that
are used to generate code idioms, are: `.initialize()`, `.add()`,
`.generate()`, `init_containers()`, `.update_containers()`,
`.get_templates()`.

Creating an extension module is carried out by the following steps:

- create and add components to `Base` subclass instances,
  for example, start with creating an `ExtensionModule` instance. 
  Components can be added with `.add(component, label=None)` method.
  Note that some components (dependencies) may be added
  in `.initialize()` method that is called by the constructor
  of the `Base` subclass.

- generate code by calling the `.generate()` method. 

- compile and build an extension module using the generated code.
  ExtGen provides a way to do it via `.build()` method
  of the `ExtensionModule` instance. Calling this method
  will generate extension module, compiles it and returns the
  corresponding extension module instance.

These steps will be discussed in more detail below.

The `.components` attribute is a list object that contains instances
of `Base` subclasses (components). For instance, the `PyCFunction` instance
defined in the Hello example above, is a component of
`ExtensionModule` instances after calling `.add()` method. Similarly,
the C statement `'printf("Hello!\\n");'` is a component of
`PyCFunction` instance after calling the `.add()` method.

The `.template` attribute is a string containing an template
to a code idiom. Such an template may contain string replacements
names that are replaced with code idioms generated by the components
--- template evaluation.
If the class should have more than one template then redefine
`.get_templates()` method that should return a tuple of templates.

The `.containers` attribute is a mapping between a replacement name
(container label) used in template strings and a `Container` instance
holding code idioms from component generation process. The mapping
`.containers` is updated by the `.init_containers()` and
`.update_containers()` methods. These methods should use
`.get_container(<container label>)` to inquire container instances
and `Container.add(<code idiom string>, label=None)` method to add
new code idioms to containers.

The `.generate()` method will call `.init_containers()` method, the
`.generate()` methods of components, and `.update_containers()` method
to generate code idioms and save the results to the corresponding
containers.  Finally, it returns the results of applying
`.evaluate(<string>)` method to templates which replaces the
replacement names with code idioms from containers as well as string
valued attributes of the given `Base` subclass instance. One can set
attributes inside `.initilize()` method.

Here follows a simplified version of `ExtensionModule.template`::

  #include "Python.h"
  
  %(Header)s
  %(TypeDef)s
  %(Extern)s
  %(CCode)s
  %(CAPICode)s
  %(ObjDecl)s
  
  static PyObject* extgen_module;
  
  static PyMethodDef extgen_module_methods[] = {
    %(ModuleMethod)s
    {NULL,NULL,0,NULL}
  };
  
  PyMODINIT_FUNC init%(modulename)s(void) {
    extgen_module = Py_InitModule("%(modulename)s", extgen_module_methods);
    %(ModuleInit)s
    return;
  capi_error:
    if (!PyErr_Occurred()) {
      PyErr_SetString(PyExc_RuntimeError, "failed to initialize %(modulename)s module.");
    }
    return;
  }
  
Here `Header`, `TypeDef`, etc are the labels of containers which will be replaced
during evaluation of templates.

Using `Container` class
=======================
    
`Container` class has the following optional arguments:

  - `separator='\n'`
  - `prefix=''`
  - `suffix=''`
  - `skip_prefix_when_empty=False`
  - `skip_suffix_when_empty=False`
  - `default=''`
  - `reverse=False`
  - `use_indent=False`
  - `use_firstline_indent=False`
  - `indent_offset=0`
  - `user_defined_str=None`

that can be used to change the behaviour of `Container.__str__()`
method.  By default, `Container.__str__()` method returns
`prefix+separator.join(<Container instance>.list)+suffix`.

One can add items to `Container` instance using `.add(<string>,
label=None)` method.  Here `label` should contain an unique value that
represents the content of `<string>`.  If `label` is `None` then
`label = time.time()` will be set.

If one tries to add items with the same label to the container then
the equality of the corresponding string values will be checked. If
they are not equal then `ValueError` is raised, otherwise adding an
item is ignored.


Component classes
=================

ExtGen package defines the following extension module component classes:

  - `ExtensionModule(<modulename>, *components, numpy=False,
    provides=.., title=.., description=..)`  ---
    represents an extension module,
    
  - `PyCFunction(<name>, *components, provides=.., title=.., description=..)` ---
    represents an extension function.

  - `PyCArgument(<name>, *components, provides=.., input_intent=..,
    output_intent=.., input_title=.., input_description=..,
    output_title=, output_description=..)` --- represents an argument component for
    `PyCFunction`. Keyword arguments `input_intent` and
    `output_intent` may have values `'required'`, `'optional'`,
    `'extra'`, `'hide'` and `'hide'`, `'return'`, respectively.

  - `CCode(*lines, provides=..)` --- represents any C code block or statement.

